{"data":{"allMarkdownRemark":{"edges":[{"node":{"fileAbsolutePath":"/Users/chenliang/Documents/我的网站/gatsby-site/src/file/articles/compose函数.md","id":"28e816e5-b561-5713-8f6d-c573c7a6b9d1","html":"<h4>compose函数的作用就是组合函数，依次组合传入的函数，控制函数的执行顺序</h4>\n<pre><code>function compose (middleware) {\n  //判断middleware是否为函数数组\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n    //返回一个匿名函数\n  return function (next) {\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n      if (i &#x3C;= index) return Promise.reject(new Error('next() called multiple times'))\n      //根据下文可知index是从-1递增\n      index = i\n      let fn = middleware[i]\n      //如果函数数组被遍历完，并且i===middleware.length,此时fn 应该为undefined；之后把next函数赋值给fn\n      if (i === middleware.length) fn = next\n      //结束递归条件，返回promise\n      if (!fn) return Promise.resolve()\n      try {\n        /*\n            实现递归，执行fn，并返回promise，这里需要注意与常用的递归实现方法不同，\n            dispatch函数对自身的调用是通过对fn的传参，这样通过递归实现了对middleware\n          的遍历，fn的执行顺序就如下图的洋葱模型一样，这也是koa的经典模型\n        */  \n        return Promise.resolve(fn(dispatch.bind(null, i + 1)));\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n</code></pre>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/228461/1560839350790-abfa60ee-a3d8-44d8-aee5-ff4be9ea2e16.png\" alt=\"image.png\"></p>\n<p>koa洋葱模型</p>\n<h4>测试：</h4>\n<pre><code>let fun1 = function (next) {\n  console.log(1)\n  /*\n    执行传入的next函数，next在这里相当于compose里的dispatch函数，执行\n    next就相当于dispatch对自身的调用，从而可以继续执行middleware当中剩\n    下的fn函数。由于返回的是promise，所以可以异步等待next的执行，\n  */ \n  next()\n  /*\n    next执行完毕才会打印后面的内容，这里并不会直接打印'next1'，而是等待后\n    边的函数先执行\n  */\n  console.log('next1')\n}\n\nlet fun2 = function (next) {\n  console.log(2)\n  next()\n  console.log('next2')\n}\n\nlet fun3 = function (next) {\n  console.log(3)\n  /*\n    由于fun3是middleware数组当中的最后一个函数，所以传入的next函数为\n    compose返回的匿名函数的参数，在这里为say函数，所以会在3和next3当\n    中打印1000\n  */\n  next()\n  console.log('next3')\n}\n\nlet say = function () {\n  console.log(1000)\n}\n\ncompose([fun1, fun2, fun3])(say)\n</code></pre>\n<p>打印结果 <code>1，2，3，1000，next3，next2，next1</code></p>\n<p>参考源码地址：<a href=\"https://github.com/koajs/compose/blob/master/index.js\">https://github.com/koajs/compose/blob/master/index.js</a></p>","frontmatter":{"date":"May 04, 2020","title":"compose函数"}}},{"node":{"fileAbsolutePath":"/Users/chenliang/Documents/我的网站/gatsby-site/src/file/articles/从迭代器的无穷序列里取值.md","id":"07c32b3c-3d16-5fb4-97e3-d1c825f0ea06","html":"<pre><code>//无穷序列的可迭代对象\nlet index = 0 \nlet sequence = {\n  [Symbol.iterator] ()  {\n    return {\n      next(){\n        return {value: index++}\n      }\n    }\n  }\n}\n//中间层take包装\nfunction take(sequence, aount) {\n  return {\n    [Symbol.iterator]() {\n      let iter = sequence[Symbol.iterator]()\n      return {\n        next() {\n          if (aount-- &#x3C; 1) {\n            return {\n              done: true\n            }\n          } else {\n            return iter.next()\n          }\n        }\n      }\n    }\n  }\n}\n\nconsole.log([...take(sequence, 10)])\n</code></pre>","frontmatter":{"date":"May 04, 2020","title":"从迭代器的无穷序列里取值"}}},{"node":{"fileAbsolutePath":"/Users/chenliang/Documents/我的网站/gatsby-site/src/file/articles/深拷贝函数.md","id":"cecf1b7d-d7fb-5393-ae21-e07e4e613951","html":"<p>不比比，直接贴函数</p>\n<pre><code>function fclone(obj) {\n    if (!obj || \"objet\" !== typeof obj) return obj;\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    let copy = {};\n    let keys = Object.keys(obj);\n    let l = keys.length;\n    while (l--) {\n        let k = keys[l];\n        copy[k] = fclone(obj[k]);\n    }\n    return copy;\n}\n</code></pre>\n<p>首先函数内部维护一个新对象copy，之后while循环遍历原对象属性，可以看到对属性赋值时再次调用了函数本身，实现递归。递归的结束条件是判断属性值的类型，如果为object类型，则继续相同的操作调用自身，实现深度访问以及拷贝。</p>\n<p>参考npm包：<a href=\"https://github.com/soyuka/fclone\">https://github.com/soyuka/fclone</a></p>","frontmatter":{"date":"May 04, 2020","title":"深拷贝函数"}}},{"node":{"fileAbsolutePath":"/Users/chenliang/Documents/我的网站/gatsby-site/src/file/articles/first.md","id":"2275f083-f594-5b1f-b037-e18888610fc2","html":"<p>新的一年 努力奋斗！！！</p>","frontmatter":{"date":"January 22, 2020","title":"我的第一篇文章"}}}]}}}