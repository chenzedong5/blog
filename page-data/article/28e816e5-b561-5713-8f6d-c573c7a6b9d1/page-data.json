{"componentChunkName":"component---src-components-article-item-jsx","path":"/article/28e816e5-b561-5713-8f6d-c573c7a6b9d1/","result":{"data":{"markdownRemark":{"html":"<h4>compose函数的作用就是组合函数，依次组合传入的函数，控制函数的执行顺序</h4>\n<pre><code>function compose (middleware) {\n  //判断middleware是否为函数数组\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n    //返回一个匿名函数\n  return function (next) {\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n      if (i &#x3C;= index) return Promise.reject(new Error('next() called multiple times'))\n      //根据下文可知index是从-1递增\n      index = i\n      let fn = middleware[i]\n      //如果函数数组被遍历完，并且i===middleware.length,此时fn 应该为undefined；之后把next函数赋值给fn\n      if (i === middleware.length) fn = next\n      //结束递归条件，返回promise\n      if (!fn) return Promise.resolve()\n      try {\n        /*\n            实现递归，执行fn，并返回promise，这里需要注意与常用的递归实现方法不同，\n            dispatch函数对自身的调用是通过对fn的传参，这样通过递归实现了对middleware\n          的遍历，fn的执行顺序就如下图的洋葱模型一样，这也是koa的经典模型\n        */  \n        return Promise.resolve(fn(dispatch.bind(null, i + 1)));\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n</code></pre>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/228461/1560839350790-abfa60ee-a3d8-44d8-aee5-ff4be9ea2e16.png\" alt=\"image.png\"></p>\n<p>koa洋葱模型</p>\n<h4>测试：</h4>\n<pre><code>let fun1 = function (next) {\n  console.log(1)\n  /*\n    执行传入的next函数，next在这里相当于compose里的dispatch函数，执行\n    next就相当于dispatch对自身的调用，从而可以继续执行middleware当中剩\n    下的fn函数。由于返回的是promise，所以可以异步等待next的执行，\n  */ \n  next()\n  /*\n    next执行完毕才会打印后面的内容，这里并不会直接打印'next1'，而是等待后\n    边的函数先执行\n  */\n  console.log('next1')\n}\n\nlet fun2 = function (next) {\n  console.log(2)\n  next()\n  console.log('next2')\n}\n\nlet fun3 = function (next) {\n  console.log(3)\n  /*\n    由于fun3是middleware数组当中的最后一个函数，所以传入的next函数为\n    compose返回的匿名函数的参数，在这里为say函数，所以会在3和next3当\n    中打印1000\n  */\n  next()\n  console.log('next3')\n}\n\nlet say = function () {\n  console.log(1000)\n}\n\ncompose([fun1, fun2, fun3])(say)\n</code></pre>\n<p>打印结果 <code>1，2，3，1000，next3，next2，next1</code></p>\n<p>参考源码地址：<a href=\"https://github.com/koajs/compose/blob/master/index.js\">https://github.com/koajs/compose/blob/master/index.js</a></p>","frontmatter":{"date":"May 04, 2020","title":"compose函数"}}},"pageContext":{"id":"28e816e5-b561-5713-8f6d-c573c7a6b9d1"}}}