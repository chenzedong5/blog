{"componentChunkName":"component---src-components-article-item-jsx","path":"/article/cecf1b7d-d7fb-5393-ae21-e07e4e613951/","result":{"data":{"markdownRemark":{"html":"<p>不比比，直接贴函数</p>\n<pre><code>function fclone(obj) {\n    if (!obj || \"objet\" !== typeof obj) return obj;\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    let copy = {};\n    let keys = Object.keys(obj);\n    let l = keys.length;\n    while (l--) {\n        let k = keys[l];\n        copy[k] = fclone(obj[k]);\n    }\n    return copy;\n}\n</code></pre>\n<p>首先函数内部维护一个新对象copy，之后while循环遍历原对象属性，可以看到对属性赋值时再次调用了函数本身，实现递归。递归的结束条件是判断属性值的类型，如果为object类型，则继续相同的操作调用自身，实现深度访问以及拷贝。</p>\n<p>参考npm包：<a href=\"https://github.com/soyuka/fclone\">https://github.com/soyuka/fclone</a></p>","frontmatter":{"date":"May 04, 2020","title":"深拷贝函数"}}},"pageContext":{"id":"cecf1b7d-d7fb-5393-ae21-e07e4e613951"}}}